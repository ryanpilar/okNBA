import pytz
import espn_api
import random
import requests
from espn_api.basketball import League
from datetime import datetime, timezone, timedelta
from basketball_reference_web_scraper import client

import ClassRun as cr
import ClassPlayer as cp
import ClassAllPlayersData as capd

class Data_Center():
    
    def __init__(self, url, cookie_1, cookie_2):
        
        self.leagueId = 782572893
        self.url = 'https://fantasy.espn.com/basketball/league?leagueId=782572893'
        self.cookie_1 = '{A56FA83E-6D2F-4FEE-A0F1-DF40E6E6E37B}'
        self.cookie_2 = 'AECMc4f57PhqXs4SSvLP6l0tflCcSozcJMn%2Fes72NwWOzjlFYOZtTjK1I7QZw%2FQnlrig6GD7o1NnralBInkz7RRFySM3crHh0x7GkT2IjhUHcriPH%2F4qJLRv8af4MHKUVOQ1hILNaJj5iu9xnkFEosOCdTQ8BaTWmhUvv%2BIhS7vg8wy8%2Fd84S32iqz7i5MSUVpPvrHRp0%2B1YWPWnf8xvBZWh3EyKUUqHEsPHm4CUt6gH4HymF2%2B89zQcLcYaKD31lIZQ8LdZX01ljfQwKu9pUxTa'
        self.TeamData = {}
        self.FantasyTeams = []
        self.calander = None
        self.moreAttention = []             # this is a list of espn player objects
        self.column_headers = ['Name', 'Pos', 'Tm', 'Gm', 'MP',
                               'FG', '3s', 'FT%', 'Ast', 'Stl',
                               'Blk', 'TOV', 'TRB', 'Pts', 'Dbl',
                               'Avg Rank']

        self.categoriesFrom_ESPN = ['MPG', 'FGM', '3PTM', 'FT%',
                                    'AST', 'STL', 'BLK', 'TO',
                                    'REB', 'PTS']
        
        self.categoriesFrom_BasketballReferance = ["Pos", "Tm", "G",
                                                   "MP", "FG", "3P",
                                                   "FT%", "AST", "STL",
                                                   "BLK", "TOV", "TRB",]

        self.keyFunctions = [
            cp.Player.getField_goals, cp.Player.getThree_pointer,
            cp.Player.getFreethrow_per, cp.Player.getAssist, cp.Player.getSteals, 
            cp.Player.getBlocks, cp.Player.getTurnovers, cp.Player.getRebounds,
            cp.Player.getPoints, cp.Player.getDoubles
            ]

        
        # using the requests library, use the url and needed cookies
        r = requests.get(self.url, cookies = {"swid": self.cookie_1, "espn_s2": self.cookie_2})

        # from the espn_api.basketball, make a league object
        league = League(self.leagueId, year=2022, espn_s2 = self.cookie_2, swid = self.cookie_1)
        
        self.espn_api_object = league

        
        # create a AllPlayer Data Object / load all player stats 
        self.AllPlayerData = cr.loadData()
    

        

    def getAllPlayerData(self):
        return self.AllPlayerData
    def getESPN_object(self):
        return self.espn_api_object
    def getTeamData(self):
        return self.TeamData
    def getFantasyTeams(self):
        return self.FantasyTeams
    def getCalander(self):
        return self.calander
    def getColumnHeaders(self):
        return self.column_headers
        
    

    def copyDictionary(self):
        print('')
        print('Copying Dictionary')
        # Step 1
        import pickle

        ClassAllPlayersData_dictionary = self.getAllPlayerData()

        '''we use the with keyword and the open function to create a file handle 
        that points to config.dictionary in the same directory where we will run 
        save_dictionary_to_file.py.

        The first string that we supply to the open function denotes the 
        filepath to write our dictionary of values. The second string that we 
        supply to the open function indicates that we want a file handle that 
        writes binary contents to the file.

        The with keyword ensures that the file handle generated by the open 
        function is closed after our dictionary is serialized to file
        '''  
         
        # Step 2
        with open('ClassAllPlayersData.dictionary', 'wb') as ClassAllPlayersData_dictionary_file:
         
            # Step 3

            '''
            we use the pickle.dump function to write the contents of our dictionary 
            to a file that will be named as config.dictionary.

            After running save_dictionary_to_file.py, we should be able to see the 
            config.dictionary file in the same directory where we run our Python script.
            '''

            pickle.dump(ClassAllPlayersData_dictionary, ClassAllPlayersData_dictionary_file)

        print('     Finished')
        print('')

    def updateFreeAgents(self, toPrint = False):
        '''this iterates over espn_free agents, and adds whatever players that were not already added to AllPlayerData'''
        
        
        yes = []                                         # player already in AllPlayer           
        no = []                                          # player is NOT in our data set and needs to be looked up

        for position in ['PG', 'SG', 'SF', 'PF', 'C']:
            
            # Pull all the ESPN_api free agents for the given position
            for player in (self.getESPN_object().free_agents(1, 1000, position, None)):
                
                name = str(player.name)
                allplayerobject = self.getAllPlayerData()
                normal = capd.AllPlayersData.normalizeText(name)


                # search to see if espn_object is in AllPlayer Data
                if self.getAllPlayerData().searchPlayer(normal):
                    if not player in yes:
                        # we don't need the data if its already in AllPlayer
                        yes.append(player)
                else:   # filter player data that is not in our dataset:
                    if not player in no:
                        no.append([position, player])
##        print('')
##        print('these players are NOT in our database')
##        
##        print(no)
##        print('')

        self.moreAttention = no
        
        alist = []
        alist2 = []

        # i example, [0] being a string, [1] an espn object == ['PG', Player(Davion Mitchell)]
##        for i in no:
##
##          
##            
##            try:
##                stats = i[1].stats
##                print(stats)
##
##                # get rid of players that have empty data
##                if stats == {}:
##                    continue
##                # get player data from espn
##                for value in stats.values():
##                    data = value['avg']
##                    check = False
##                    
##                    aDict = {}
##                    aList = ['MIN', 'GP', 'MPG', 'FGM', '3PTM', 'FT%', 'AST', 'STL', 'BLK', 'TO', 'REB', 'PTS']
##                    for category in aList:
##                        try:
##                            theData = data[category]
##                            aDict[category] = theData
##                        except Exception as error:
##                            aDict[category] = 0.0
##                            #print('     Error updateFreeagents 1', i[1].name, error, category)
##                            check = True
##                    
##                    
##
##
##                    name = capd.AllPlayersData.normalizeText(str(i[1].name))
##      
##                    # make a Player object, using espn-api data for input paramaters
##                    addPlayer = cp.Player(name, i[0], i[1].proTeam, aDict['GP'], aDict['MPG'],
##                                          aDict['FGM'], aDict['3PTM'], aDict['FT%'],
##                                          aDict['AST'], aDict['STL'], aDict['BLK'],
##                                          aDict['TO'], aDict['REB'], aDict['PTS']
##                                          )
##                    self.getAllPlayerData().addPlayer(addPlayer)
##                    yes.append(i[1])
                        
                       # check to see if the False entries were added
                        #if check == True:
                        #print('IT IS VERY TRUE ADD?>', self.getAllPlayerData().searchPlayer(name))
                        
                    
##
##            except Exception as error:
##
##                   
##                alist.append(i)
##                print('    Error 2 updateFreeagents', name, value)
##                print('error message:', error)
##
##                pass

        if toPrint:

            print('\n', 'Misc Free Agent Names That Did Not Convert Well:')
            for i in alist:
                print('\t', i)
                

        
        self.moreAttentionPlease()    #this will go threw the duplicates generated from the espon app
        
        self.updatePositions(yes)
        
        for i in self.getAllPlayerData().getDict():
            if type(i.position) == list:
                pass
            else:
                i.position = [i.position]                   # other functions depend on list structures        
      
        # manually update the positions for the following Players:
        #player = [('keita bates-diop', ['SF']), ('alec burks', ['SG']), ('gary clark', ['PF']), ('robert covington', ['PF']), ('jae crowder', ['PF', 'SF']),
         #         ('james ennis', ['SG', 'SF']), ('jeff green', ['PF']), ('maurice harkless', ['SF']), ('reggie jackson', ['PG']), ('james johnson', ['PF', 'SF']),
          #        ('tyler johnson', ['PF', 'SG']), ('brandon knight', ['PG']), ('marcus morris', ['PF', 'SF']), ('caleb swanigan', ['PF'])]

        #for i in player:
            
            #player_object = self.getAllPlayerData().getPlayer_object(i[0])
            #player_object.getPosition = i[1]
            



    def moreAttentionPlease(self):

        aList = self.moreAttention
        noDuplicates_list = []

        for player in aList:

            if player[1].name in noDuplicates_list:
                pass
            else:
                noDuplicates_list.append(player[1].name)
                
        print('')
        print('noDuplicates() list', noDuplicates_list, len(noDuplicates_list))

        for i in noDuplicates_list:
            print(i)
                
    def modularizeAddPlayers(self, no):

        for i in no:

          
            
            try:
                stats = i[1].stats


                # get rid of players that have empty data
                if stats == {}:
                    continue
                # get player data from espn
                for value in stats.values():
                    data = value['avg']
                    check = False
                    

                    aDict = {}
                    aList = ['MPG', 'FGM', '3PTM', 'FT%', 'AST', 'STL', 'BLK', 'TO', 'REB', 'PTS']
                    for category in aList:
                        try:
                            theData = data[category]
                            aDict[category] = theData
                        except Exception as error:
                            aDict[category] = 0.0
                            #print('     Error updateFreeagents 1', i[1].name, error, category)
                            check = True
                    


                    
                    name = capd.AllPlayersData.normalizeText(str(i[1].name))
      
                    # make a Player object, using espn-api data for input paramaters
                    addPlayer = cp.Player(name, i[0], i[1].proTeam, [], aDict['MPG'],
                                          aDict['FGM'], aDict['3PTM'], aDict['FT%'],
                                          aDict['AST'], aDict['STL'], aDict['BLK'],
                                          aDict['TO'], aDict['REB'], aDict['PTS']
                                          )
                    self.getAllPlayerData().addPlayer(addPlayer)

                    # check to see if the False entries were added
                    #if check == True:
                        #print('IT IS VERY TRUE ADD?>', self.getAllPlayerData().searchPlayer(name))
                        
                    yes.append(i[1])

            except Exception as error:

                   
                alist.append(i)
                print('    Error 2 updateFreeagents', name, value)
                print('error message:', error)

                pass

    def updatePositions(self, alist):
        print('updatePositions...')

        for i in alist:

            update = []
            for pos in i.eligibleSlots:
                if pos == 'G' or pos == 'G/F' or pos == 'UT' or pos == 'BE' or pos == 'Rookie' or pos == 'IR' or pos == 'F' or pos == 'F/C':
                   pass
                else:
                    update.append(pos)

            # look up Player object and update his position
            normal = capd.AllPlayersData.normalizeText(str(i.name))
            player_object = self.getAllPlayerData().getPlayer_object(normal)

            player_object.position = update

        print('     Finished')

    def updateTeamData(self, week = 0):

        '''
        This function grabs the current weeks matchups via the espn_api. It then looks at each
        team's roster and converts the corresponding espn_api objects  into AllPlayerData objects.

        subsequently, self.TeamData is updated with this new information.
        '''
        print('\n', 'updating TeamData...')
        
        matchups = self.getESPN_object().scoreboard(week)
        not_entered = []
        Team_Data = {}
        date = datetime.now().date()

        for match in matchups:
                                                                # unpack the espn_api matchup object
            the_teams = [match.home_team, match.away_team]
                                                                # [key] espn.api team objects
            Team_Data[match.home_team] = [[],[]]                # [0] roster of espn.api player objects
            Team_Data[match.away_team] = [[],[]]                # [1] roster of AllPlayerData.getPlayer_object's
            
            for team in the_teams:                          
                player_object_list = team.roster                # these are espn_api player objects
                
                for player_object in player_object_list:

                    
                    
                    Team_Data[team][0].append(player_object)    

                    name = player_object.name                   # normamlize text
                    player_string = capd.AllPlayersData.normalizeText(str(name))
                    
                                                                # before preoceeding. varify normalized text is in AllPlayerData
                                                                # if this throws False, then we know something is up
# see line 151 for duplications. make a function to modularize this:
                    if not self.AllPlayerData.searchPlayer(player_string):
                        Team_Data[team][1].append(player_string)
                        not_entered.append(player_string)
                        print('---not entered:', player_string, "SO ADD IT AND CHECK IT!")
                        print(player_object)

                        


                        
                    else:                                       # use normalized text to getPlayer_object in AllPlayerData
                        Team_Data[team][1].append(self.AllPlayerData.getPlayer_object(player_string))
                                                                # !!ALSO!! correct player position in AllPlayerData !!HERE!!
                        all_player_object = self.AllPlayerData.getPlayer_object(player_string)
                        all_player_object.position = player_object.eligibleSlots

                        

                        
        self.TeamData = Team_Data                               # update self.TeamData
        print('     Finished')

        self.correctPositions()                                 # positions coming from espn_api is always dirty

        


    def correctPositions(self):
        ''' accepts a player object fetched from the espn_api. It gives up to date position information but its a list that also includes
some ambiguous . This function removes the ambiguous entries, and returns ONLY the player positions'''

        # go into self.TeamData and grab all the players espn_api objects (who will be assigned to teams)
        # use those espn_api objects to look up their positions
        # use those position values and update Player() data

        print('\n', 'correctPositions...')

        all_players = self.getAllPlayerData().getDict()
        to_be_removed = ['G', 'SG/SF', 'G/F', 'UT', 'BE',
                     'Rookie', 'PF/C', 'IR', 'F', 'F/C']


        for player in all_players:


            updated_position = []

            for position in player.position:
                if position in to_be_removed:
                    pass
                else:
                    updated_position.append(position)
            player.position = updated_position

        print('     Finished')

    def correctTeam(self):
        ''' takes in a espn_api object that has the correct team information, it then looks up the player
in the AllPlayersData dictionary, and updates his position'''

        print('\n', 'correctTeam')
        for key, value in self.getTeamData().items():

    
            # iterate over the espn_api players in every fantasy team
            for i in value[0]:
                name, team_initials = i.name, i.proTeam

                try:
                    # get AllPlayer Object
                    normalized = capd.AllPlayersData.normalizeText(str(name))
                    AllPlayer_object = self.AllPlayerData.getPlayer_object(normalized)
                    # update correct initials
                    AllPlayer_object.team = team_initials
                except:
                    print('did not work correcTeam', name, team_initials)
                    pass

        print('     ', 'Finished')

    def getLeaguePlayers(self):

        e = self.getTeamData()
        alist = []
        
        for key, value in e.items():
            
            players = value[1]
            for player in players:
                alist.append(player)

        return alist

    def getFreeAgents(self, toPrint = False):
        just_league_players = self.getLeaguePlayers()
        whole_league = self.getAllPlayerData().getDict()

        alist = []

        
        for player in whole_league:
            if not player in just_league_players:
                if not player.getTotalRank() == None:
                    alist.append(player)

        keyFunction = cp.Player.getTotalRank
        sorted_copy = sorted(alist, key = keyFunction, reverse = False)

        if toPrint:
            for i in sorted_copy:
                print(i.position, i.getTotalRank(), i.getPlayer())

        #return sorted_copy



